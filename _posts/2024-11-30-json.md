---
layout: post
title: json interface between ui and physics engine
description: >
  Implementation of a JSON interface between the RealTimeParticles UI and its physics engine.

  **Source code available [here](https://github.com/axoloto/RealTimeParticles).**
sitemap: false
hide_last_modified: false
category : rtp
image: /assets/img/blog/json/boidsBox.jpg
accent_image: 
  background: url('/assets/img/blog/json/boidsBox.jpg') center/cover
  overlay: false
accent_color: '#ccc'
theme_color: '#ccc'
---

# How to connect your UI and C++ engine with JSON

1. this list will be replaced by the table of contents
{:toc}

## Introduction

Last year, I posted a deep technical blog post (link) about periodic boundary conditions within a Position Based Dynamics (PBD) framework. It was part of my work implementing a PBD clouds model, based on a series of scientific papers (links). At the end of the post, I promised that my next one would be about those clouds experiments, but it will unlikely happen soon. First, my professional life has been hectic in the past year. Diving back into the complexity of clouds physics would require too much time. Second, honestly I'm not super happy with the results. I did manage to get some nice realtime clouds dynamics but the visuals are lacking. I want to implement a proper volume renderer to properly highlight the simulated clouds dynamics. This is still on my to-do list so clouds explanations will have to wait.

Instead, let's focus on something lighter that has been a growing pain: **How can I implement a generic and automatic interface between my various physical models and the UI of my RealTimeParticles application?** Everytime a model is added, a lot of UI/engine connections must be done manually, and complexity is growing in an unsubstainable way. As you have probably guessed from the title of this blog post, the answer is JSON, a powerful data interchange format coming from Web development that can also help us tremendously in software development.

Regarding the structure of this blog post, I will first present the current problematic state of my connection UI/engine, then how JSON works and finally how I can use it in my situation to reduce the boilerplate for my next model implementation. No fancy theory here, and no specific knowledge requested aside from a classic computer science background. Let's get right into it!

## A simple but unsubstainable UI/engine interface

-Picture of the app / RealTimeParticles 1.0 with main widget (top-left), graphics widget (bottom-left) and physics widget (right) for clouds model.

For those who have played a bit with my RealTimeParticles (RTP) application, it probably seems obvious that UI/UX is not very high in my list of priorities. I only implemented the strict minimum to play with the implemented physical models and adjust their rendering. Thus, the UI is very basic, it is just a couple of widgets on top of DearImgui (link). For every frame, these widgets obtain data from the physics and graphics engines through getters, render it, and update through setters any value modified by the users. 

-Diagram 1 notebook - UI/Widget interactions

The connection to UI is very similar for the two engines. However it is very limited on Graphics side as it doesn't necessitate many parameters, so let's focus on the Physics side where we keep adding models. Here are some details of the implementation on UI and engine sides for the Clouds model:
~~~cpp
  ImGui::Spacing();
  ImGui::Text("Clouds Parameters");
  ImGui::Spacing();

  bool isTempSmoothingEnabled = cloudsEngine->isTempSmoothingEnabled();
  if (ImGui::Checkbox("Enable Temperature Smoothing", &isTempSmoothingEnabled))
  {
    cloudsEngine->enableTempSmoothing(isTempSmoothingEnabled);
  }

  float groundHeatCoeff = cloudsEngine->getGroundHeatCoeff();
  if (ImGui::SliderFloat("Ground Heat Coefficient", &groundHeatCoeff, 0.0f, 1000.0f, "%.4f"))
  {
    cloudsEngine->setGroundHeatCoeff(groundHeatCoeff);
  }

  float buoyancyCoeff = cloudsEngine->getBuoyancyCoeff();
  if (ImGui::SliderFloat("Buoyancy Coefficient", &buoyancyCoeff, 0.0f, 5.0f, "%.4f"))
  {
    cloudsEngine->setBuoyancyCoeff(buoyancyCoeff);
  }

  float gravCoeff = cloudsEngine->getGravCoeff();
  if (ImGui::SliderFloat("Gravity Coefficient", &gravCoeff, 0.0f, 0.1f, "%.4f"))
  {
    cloudsEngine->setGravCoeff(gravCoeff);
  }
~~~
At the beginning of the clouds section in PhysicsWidget.cpp

~~~cpp
  void enableTempSmoothing(bool enable);
  bool isTempSmoothingEnabled() const;
  //
  void setGroundHeatCoeff(float coeff);
  float getGroundHeatCoeff() const;
  //
  void setBuoyancyCoeff(float coeff);
  float getBuoyancyCoeff() const;
  //
  void setGravCoeff(float coeff);
  float getGravCoeff() const;
~~~
Half of CloudsModel.hpp looks like this, not great

As I said, it's a very basic implementation, everything has to be declared/defined and connected manually. Also, you can note that the value range for each parameter is hardcoded in the UI. This is bad, it should be encapsulated in the definition of the physical model. Yet, in my opinion the famous approach Keeping It Stupid but Simple (link) is always a good start and this setup was totally fine at first. When there was only the boids model, it only required a couple of getter/setters and limited boilerplate on widget side. Then, I added the fluids models with a lot more parameters to tweak and I had to add one or two hundred lines of additional boilerplate, a bit more annoying but still manageable. However, the latest clouds model with 19 additional parameters made it clear that this simplistic approach was not substainable. By now, the physics widget with all the models parameters is 500 lines long and the header file of my clouds model has more than 100 lines of getters and setters. Before adding any other model to the mix, something must be done to simplify the junction between PhysicsWidget and the physical models.

Hmm... it would be nice if I could have some generic datastructure storing all my model params despite their different types, no matter the model, and then UI would loop through this datastructure, display the values and send back any modified ones to the engine. It is surely doable with a standard container and some template magic. Let's try to design this. First, let me just... Waaait! Folks, this is 2024 and almost everything already exists on the Internet, open source and MIT-licensed with some luck. What about trying to reuse someone's else magic instead of reinventing the wheel? There enters JSON!

## JSON and the golden fleece
### What's JSON?
JSON aka JavaScript Object Notation is a very popular data-interchange format that was initially implemented in JavaScript 25 years ago. It has since spread to dozens of different programming languages, being widely praised for its simplicity to read as a human and parse as a machine. Data-interchange concept refers to the process of exchanging data between different systems so that information sent by one system can be understood and used by another, even if those systems are built using different technologies, languages or platforms. In our case, the data-interchange process is relatively straightforward, the physics engine sends the names and values of its models parameters to the UI layer and in return receives values modified by the user.

### How do you represent something in JSON?
A JSON object is an ordered list of key-value pairs where values can be strings, numbers, booleans, null values, arrays and also... JSON objects! This makes it versatile and ideal for representing complex data structures. Also, JSON objects can be serialized in a JSON file. In our UI/engine case, we won't need to serialize/deserialize anything, as the two systems exchanging data are in the same C++ program so we can keep everything in the program memory. We could use serialization to save custom models parameters values in a JSON file and share it with other RealTimeParticles users for example. I won't dive too much into JSON syntax because hundreds of websites already do it really well like the [official JSON page](https://www.json.org/json-en.html), but here is an example:

~~~json
{
  "name": "Santa Claus",      // string
  "age": null,                // null value, Santa's exact age is unknown or timeless
  "address": "North Pole", // string
  "has_chimney_entry_skills": true, // bool
  "sleigh": {                   // Another JSON object
    "mileage": 34000,
    "weight": 344,
    "plate_number": null
  }
}
~~~
A basic JSON example

### JSON in C++

There is no built-in support for JSON in C++. The language was invented before the format, and the latter hasn't made its way to the standard library yet. Nevertheless, many open-source third party libraries brings JSON support to C++. Personally, I really like nohlmann::json for its convenience and accessibility. Heavily templated, it only requires a couple of headers through a single `#include<nlohmann/json.hpp>`. It also provides a lot of features for an nice integration in C++: implicit conversions, arbitrary type conversions, JSON Merge Patch, STL-container support, type checkers... Another nicety is its availability through the third-party package manager Conan already used in the RealTimeParticles application. With Conan, we can obtain the latest version of nlohmann::json header library and plug it into the application very easily.

~~~cpp
using json = nlohmann::json;

namespace ns {
    // a simple struct to model a person
    struct person {
        std::string name;
        std::string address;
        bool has_chimney_entry_skills;
    };
    // operator to convert a person object to a JSON object
    void to_json(json& j, const person& p) {
        j = json{ {"name", p.name}, {"address", p.address}, {"hasChimneyEntrySkills", p.has_chimney_entry_skills}};
    }
    // operator to convert a JSON object to a person object
    void from_json(const json& j, person& p) {
        j.at("name").get_to(p.name);
        j.at("address").get_to(p.address);
        j.at("hasChimneyEntrySkills").get_to(p.has_chimney_entry_skills);
    }
}

// create a person
ns::person p {"Santa Claus", "North Pole", true};

// conversion: person -> json
json j = p;

// list is ordered and will be printed accordingly
std::cout << j << std::endl;
// {"address":"North Pole", "hasChimneyEntrySkills":true,"name":"Santa Claus"}

// conversion: json -> person
auto p2 = j.template get<ns::person>();

// that's it
assert(p == p2);
~~~
Adding JSON support to an arbitrary type with nlohmann::json

## Implementing a JSON interface in RealTimeParticles

### What's the plan?

Alright, now that we have presented our current UI/engine issue and quickly introduced JSON, let's see how we can leverage it in this situation which is getting out of hands. In order to aim toward this ideal of a generic and automatic interface between UI and physics engine, **the focus is to get rid of all the parameters' getters/setters boilerplate on the engine side and to automate the generation of the physics widget on the UI side.** Doing so, adding a new physics parameter or model will be straightforward. Also, keep in mind that the data transfer must go either way as we need to update in the engine the physics parameters values modified by the user.

To achieve this, the proposal is to store all physics parameters data of a given physical model into a JSON object owned by the model. The engine will then pass this generic JSON object to the physics UI widget which will unparse it and draw UI items for each key-value pair of the JSON. At the end of the frame, if the user has modified some values, we can then simply pass the updated JSON back to the engine which will unparse it and update the model. The round trip of the data transfer is complete.

/graph JSON flow

So let's see how JSON can help us achieve those three different steps:
- store all physics parameters data at the same place in the physics model
- draw physics widget automatically based on those parameters data
- update physics models based on user physics parameters values

### Storing inputs through JSON on engine side

In order to store all our physics data into a JSON object, we need to do quite a bit of refactoring into the physics engine. All parameters data defining a model now goes into the JSON object `m_inputJson` owned by the base class `Model`. The OpenCL implementation of this base class is called `oclModel`, and the different existing models `Boids/Fluids/Clouds` are implemented on top of it. During the refactoring, I initially focus on the fluids model and deactivate the other ones to iterate faster.

~~~cpp
// Initial state of the fluids model parameters
static const json initFluidsJson // clang-format off
{ 
  {"Fluids", {
      { "Rest Density", { 450.0f, 10.0f, 1000.0f } },
      { "Relax CFM", { 600.0f, 100.0f, 1000.0f } },
      { "Time Step", { 0.010f, 0.0001f, 0.020f } },
      { "Nb Jacobi Iterations", { 2, 1, 6 } },
      { "Artificial Pressure",
          { { "Enable##Pressure", true },
            { "Coefficient##Pressure", { 0.001f, 0.0f, 0.001f} },
            { "Radius", {0.006f, 0.001f, 0.015f}},
            { "Exp", {4, 1, 6}}
          }
      },
      { "Vorticity Confinement",
          { { "Enable##Vorticity", true },
            { "Coefficient##Vorticity", {0.0004f, 0.0f, 0.001f}},
            { "xSPH Viscosity Coefficient", {0.0001f, 0.0f, 0.001f}}
          }
      }
    }
  }
}; // clang-format on

Fluids::Fluids(ModelParams params)
    : OclModel<FluidKernelInputs>(params, FluidKernelInputs {}, json(initFluidsJson)) // Initialize Fluids with initFluidsJson
    //...
~~~
All fluids model parameters are stored in a JSON object with their default values

As shown above, the fluids model parameters with their initial values are stored in a single JSON object `initFluidsJson`. For numerics values, we have the following layout: `name - {default val, min val, max val}`, using an array for the values. Compared to the original design, encapsulation is much better with the range value of each parameter stored in the model itself aside its current value. Also note the two sub-JSON objects `Artifical Pressure` and `Vorticity Confinement` used for conditional parameters that can enable other parameters if active.

~~~cpp
Model(ModelParams params, json js = {})

json getInputJson() const
{
  return m_inputJson;
}

void updateInputJson(const json& newJson)
{
  // No modification, no update
  if (json::diff(m_inputJson, newJson).empty())
    return;

  m_inputJson.merge_patch(newJson);
  updateModelWithInputJson();
}

virtual void updateModelWithInputJson() = 0;
~~~
JSON input integration in the physics engine at `Model` level

The implementation at `Model` level ends up being quite straightforward. The input json is logically passed as a constructor parameter. Also, instead of having dozens of getters for each parameter, we have now greatly reduced in granularity with a single `getInputJson()` API. `updateInputJson()` is the setter to update the model JSON, inside it we use the JSON Merge Patch feature to update modified parameter values of the model. Finally, note the abstract function `updateModelWithInputJson()` that must be defined for each model type, this is where the model unparses `m_inputJson` and passes the different parameters values to the GPU. We will come back to it later.

### Parsing JSON input to automatically generate UI

UI integration - diving into the two three generic func calls, no more dynamic cast

~~~cpp
void UI::PhysicsWidget::display()
{
  auto physicsEngine = m_physicsEngine.lock();

  ///...

  // Retrieve input json from the physics engine with all available parameters
  json js = physicsEngine->getInputJson();
  // Draw all items from input json
  drawImguiObjectFromJson(js);
  // Update physics engine with new parameters values if any
  physicsEngine->updateInputJson(js);
}
~~~
JSON interface between PhysicsWidget and physics engine

~~~cpp
void drawImguiObjectFromJson(json& js)
{
  for (auto& el : js.items())
  {
    auto& val = el.value();
    if (val.is_object())
    {
      ImGui::Spacing();
      ImGui::Text(el.key().c_str());
      ImGui::Indent(15.0f);
      // Recursive call
      drawImguiObjectFromJson(val);
      ImGui::Unindent(15.0f);
      ImGui::Spacing();
    }
    else if (val.is_boolean())
    {
      drawImguiCheckBoxFromJson(el.key(), val.get_ref<bool&>());

      // special case where we skip the rest of the items if "Enable" param is false
      bool skipRestOfItems = el.key().find("Enable##") != std::string::npos && val == false;

      if (skipRestOfItems)
        return;
    }
    else if (val.is_array() && val[0].get<Utils::PhysicsCase>() != Utils::PhysicsCase::CASE_INVALID)
    {
      drawImguiEnumCombo<Utils::PhysicsCase>(el.key(), val);
    }
    else if (val.is_array() && val.size() == 3 && val[0].is_number_integer())
    {
      // cannot directly access json array items by reference
      drawImguiSliderInt(el.key(), val);
    }
    else if (val.is_array() && val.size() == 3 && val[0].is_number_float())
    {
      // cannot directly access json array items by reference
      drawImguiSliderFloat(el.key(), val);
    }
  }
}
~~~

Generic and recursive function to draw all UI items with JSON object


### Updating model and GPU computes through JSON

  - Engine integration - kernel feeding workflow, using json input to feed kernel inputs, no need to dive into newly added kernelInput templated implementation

  -bonus enum string mapping  - physical case for ex    NLOHMANN_JSON_SERIALIZE_ENUM

## Results 

  before/after UI wise, generic, less customized but okay, code wise, how many lines removed/added

  performance wise, negligible

  pros and cons
   super fast to add a new model, no more need to adjust small bits of the UI, small formating and else, just focus on generic logic and impact everywhere
   less safe? bit more constrainted

another nice to have - json mapping enum string

## Final thoughts

Conclusion
Go for it!


